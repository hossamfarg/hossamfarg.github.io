<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>exist â€” Internet Reachability Probe</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0b0d10;
      --panel: #141820;
      --muted: #9aa4b2;
      --fg: #e6edf3;
      --accent: #5cc2ff;
      --ok: #2bb673;
      --warn: #ffb74d;
      --err: #ff6b6b;
      --chip: #1e2530;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
      color: var(--fg);
      background: radial-gradient(1200px 700px at 15% -10%, #172033, var(--bg));
    }
    header, main {
      max-width: 980px;
      margin: 0 auto;
      padding: 16px;
    }
    header {
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
    }
    .title {
      display: flex;
      gap: 12px;
      align-items: center;
    }
    h1 { font-size: 20px; margin: 0; }
    .badge {
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 999px;
      background: var(--chip);
      color: var(--muted);
    }
    .row { display: flex; gap: 12px; flex-wrap: wrap; }
    .panel {
      background: var(--panel);
      border: 1px solid #1f2632;
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    .panel.wide { flex: 1 1 600px; min-width: 280px; }
    .panel.narrow { flex: 1 1 280px; min-width: 240px; }
    .grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(140px, 1fr));
      gap: 12px;
    }
    .stat {
      background: #111622;
      border: 1px solid #1a2130;
      border-radius: 10px;
      padding: 12px;
    }
    .stat .label { font-size: 12px; color: var(--muted); }
    .stat .value { font-size: 18px; margin-top: 4px; }

    .toolbar {
      display: flex; gap: 8px; align-items: center; flex-wrap: wrap;
    }
    .spacer { flex: 1; }
    .btn {
      appearance: none;
      border: 1px solid #2a3448;
      background: #1b2333;
      color: var(--fg);
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
    }
    .btn:hover { background: #212a3d; }
    .btn.primary { background: #1a6aa1; border-color: #1a6aa1; }
    .btn.primary:hover { background: #1671b0; }
    .btn.ghost { background: transparent; }
    .btn[disabled] {
      opacity: 0.6;
      cursor: not-allowed;
    }
    #btnTestNow { min-width: 120px; } /* prevent width jump when counter appears */

    .kv {
      display: grid;
      grid-template-columns: 140px 1fr;
      gap: 12px;
      align-items: center;
      margin: 10px 0;
    }
    input[type="text"], input[type="number"] {
      width: 100%;
      background: #0f1421;
      color: var(--fg);
      border: 1px solid #273149;
      border-radius: 8px;
      padding: 10px 12px;
      outline: none;
    }
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button { appearance: none; margin: 0; }
    .help { color: var(--muted); font-size: 12px; }

    /* Modal */
    dialog {
      border: 1px solid #263049;
      border-radius: 12px;
      background: var(--panel);
      color: var(--fg);
      width: min(720px, 92vw);
      padding: 0;
    }
    dialog::backdrop {
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(3px);
    }
    .modal-head { padding: 16px; border-bottom: 1px solid #1f2632; display:flex; align-items:center; justify-content:space-between;}
    .modal-body { padding: 16px; }
    .modal-foot { padding: 16px; border-top: 1px solid #1f2632; display:flex; gap:8px; justify-content:flex-end; }

    .chip {
      padding: 6px 10px;
      background: var(--chip);
      border: 1px solid #2b3446;
      border-radius: 999px;
      font-size: 12px;
      color: var(--muted);
    }
    .ok { color: var(--ok); }
    .warn { color: var(--warn); }
    .err { color: var(--err); }

    /* Screenshot images (if you embed base64 later) */
    picture img { max-width: 100%; border-radius: 8px; }
  </style>
</head>
<body>
  <header>
    <div class="title">
      <h1>exist â€” reachability</h1>
      <span id="badgeStatus" class="badge">Unknown</span>
    </div>
    <div class="toolbar">
      <button id="btnTestNow" class="btn primary" type="button">Test now</button>
      <button id="btnSettings" class="btn" type="button">Settings</button>
      <button id="btnReset" class="btn ghost" type="button">Reset data</button>
    </div>
  </header>

  <main>
    <div class="row">
      <section class="panel narrow">
        <div class="grid">
          <div class="stat">
            <div class="label">Success rate (status window)</div>
            <div id="statSuccessRate" class="value">â€”</div>
          </div>
          <div class="stat">
            <div class="label">Avg latency (ms)</div>
            <div id="statLatency" class="value">â€”</div>
          </div>
          <div class="stat">
            <div class="label">Last probe</div>
            <div id="statLast" class="value">â€”</div>
          </div>
          <div class="stat">
            <div class="label">Next auto probe</div>
            <div id="statNext" class="value">â€”</div>
          </div>
        </div>
        <div class="help" style="margin-top:10px;">
          Button cooldown follows <strong>Min interval</strong>. Automatic cadence adapts between <strong>Min/Max</strong>.
        </div>
      </section>

      <section class="panel wide">
        <div style="display:flex;gap:10px;align-items:center;margin-bottom:8px;">
          <span class="chip">Target: <span id="chipUrl">â€”</span></span>
          <span class="chip">Min: <span id="chipMin">â€”</span>s</span>
          <span class="chip">Max: <span id="chipMax">â€”</span>s</span>
          <span class="chip">Timeout: <span id="chipTo">â€”</span>s</span>
        </div>
        <div id="log" class="help" style="white-space:pre-wrap;max-height:240px;overflow:auto;border-top:1px solid #1f2632;padding-top:10px;">
          <!-- live log -->
        </div>
      </section>
    </div>

    <!-- Optional screenshots (base64) -->
    <!--
    <section class="panel" style="margin-top:12px;">
      <h3>Screenshots</h3>
      <picture>
        data:image/png;base64,{{IMG1_BASE64}}
      </picture>
    </section>
    -->
  </main>

  <!-- Settings Modal -->
  <dialog id="dlgSettings">
    <div class="modal-head">
      <strong>Settings</strong>
      <button id="btnCloseSettings" class="btn ghost" type="button">âœ•</button>
    </div>
    <div class="modal-body">
      <div class="kv">
        <label for="inUrl">Probe URL</label>
        <input id="inUrl" type="text" placeholder="https://www.yahoo.com/favicon.ico" />
      </div>
      <div class="kv">
        <label for="inMin">Min interval (seconds)</label>
        <input id="inMin" type="number" min="1" step="1" />
      </div>
      <div class="kv">
        <label for="inMax">Max interval (seconds)</label>
        <input id="inMax" type="number" min="1" step="1" />
      </div>
      <div class="kv">
        <label for="inTimeout">Timeout (seconds)</label>
        <input id="inTimeout" type="number" min="1" step="1" />
      </div>
      <div class="kv">
        <label for="inHist">History window (hours)</label>
        <input id="inHist" type="number" min="1" step="1" />
      </div>
      <div class="kv">
        <label for="inStatus">Status window (minutes)</label>
        <input id="inStatus" type="number" min="1" step="1" />
      </div>
      <div class="help">Values are persisted in your browser (localStorage).</div>
    </div>
    <div class="modal-foot">
      <button id="btnCancel" class="btn" type="button">Cancel</button>
      <button id="btnSave" class="btn primary" type="button">Save</button>
    </div>
  </dialog>

  <script>
    /**************************************************************************
     * CONFIG & STATE
     **************************************************************************/
    const DEFAULTS = {
      probeUrl: 'https://www.yahoo.com/favicon.ico',
      minIntervalSec: 30,
      maxIntervalSec: 300,
      timeoutSec: 8,
      historyHours: 12,
      statusWindowMinutes: 10,
    };

    const STORE_KEY = 'exist.settings.v1';
    const STORE_TS  = 'exist.lastProbeTs.v1';
    const STORE_HIS = 'exist.history.v1';

    let settings = loadSettings();
    let history = loadHistory(); // array of {ts, ms, ok}
    let lastProbeTs = Number(localStorage.getItem(STORE_TS)) || 0;

    // Adaptive cadence (starts mid-way)
    let currentIntervalSec = clamp(
      Math.round((settings.minIntervalSec + settings.maxIntervalSec) / 2),
      settings.minIntervalSec,
      settings.maxIntervalSec
    );

    // Timers
    let autoTimer = null;
    let cooldownTimerId = null;

    // UI refs
    const el = {
      btnTestNow: document.getElementById('btnTestNow'),
      btnSettings: document.getElementById('btnSettings'),
      btnCloseSettings: document.getElementById('btnCloseSettings'),
      btnCancel: document.getElementById('btnCancel'),
      btnSave: document.getElementById('btnSave'),
      btnReset: document.getElementById('btnReset'),
      dlg: document.getElementById('dlgSettings'),
      inUrl: document.getElementById('inUrl'),
      inMin: document.getElementById('inMin'),
      inMax: document.getElementById('inMax'),
      inTimeout: document.getElementById('inTimeout'),
      inHist: document.getElementById('inHist'),
      inStatus: document.getElementById('inStatus'),
      badgeStatus: document.getElementById('badgeStatus'),
      statSuccessRate: document.getElementById('statSuccessRate'),
      statLatency: document.getElementById('statLatency'),
      statLast: document.getElementById('statLast'),
      statNext: document.getElementById('statNext'),
      chipUrl: document.getElementById('chipUrl'),
      chipMin: document.getElementById('chipMin'),
      chipMax: document.getElementById('chipMax'),
      chipTo: document.getElementById('chipTo'),
      log: document.getElementById('log'),
    };

    /**************************************************************************
     * UTILITIES
     **************************************************************************/
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function fmtMs(ms) { return `${ms|0} ms`; }
    function fmtTime(ts) {
      if (!ts) return 'â€”';
      const d = new Date(ts);
      return d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit'});
    }
    function logln(s) {
      const now = fmtTime(Date.now());
      el.log.textContent = `[${now}] ${s}\n` + el.log.textContent;
    }
    function loadSettings() {
      try {
        const raw = JSON.parse(localStorage.getItem(STORE_KEY) || '{}');
        return { ...DEFAULTS, ...raw };
      } catch { return { ...DEFAULTS }; }
    }
    function saveSettings() {
      localStorage.setItem(STORE_KEY, JSON.stringify(settings));
    }
    function loadHistory() {
      try {
        return JSON.parse(localStorage.getItem(STORE_HIS) || '[]');
      } catch { return []; }
    }
    function saveHistory() {
      localStorage.setItem(STORE_HIS, JSON.stringify(history));
    }

    // Rolling trims
    function trimHistory() {
      const cutoff = Date.now() - settings.historyHours * 3600_000;
      history = history.filter(h => h.ts >= cutoff);
      saveHistory();
    }
    function statusWindow() {
      const cutoff = Date.now() - settings.statusWindowMinutes * 60_000;
      return history.filter(h => h.ts >= cutoff);
    }
    function computeStats() {
      const win = statusWindow();
      const okCount = win.filter(h => h.ok).length;
      const rate = win.length ? Math.round((okCount / win.length) * 100) : null;
      const lat = win.length ? Math.round(win.reduce((s, h) => s + h.ms, 0) / win.length) : null;
      return { rate, lat };
    }

    /**************************************************************************
     * COOLDOWN MANAGER (NEW)
     **************************************************************************/
    function msUntilAllowed() {
      const minMs = (settings.minIntervalSec || 0) * 1000;
      const elapsed = Date.now() - (lastProbeTs || 0);
      return Math.max(0, minMs - elapsed);
    }

    function startTestCooldown() {
      stopTestCooldown();
      const update = () => {
        const remainingMs = msUntilAllowed();
        if (remainingMs <= 0) {
          el.btnTestNow.disabled = false;
          el.btnTestNow.textContent = 'Test now';
          el.btnTestNow.setAttribute('aria-disabled', 'false');
          el.btnTestNow.title = 'Trigger a manual probe now';
          stopTestCooldown();
        } else {
          const s = Math.ceil(remainingMs / 1000);
          el.btnTestNow.disabled = true;
          el.btnTestNow.textContent = `Test now (${s}s)`;
          el.btnTestNow.setAttribute('aria-disabled', 'true');
          el.btnTestNow.title = `Available in ${s}s`;
        }
        // Also reflect next auto probe ETA
        const nextTs = (lastProbeTs || Date.now()) + currentIntervalSec*1000;
        const eta = Math.max(0, nextTs - Date.now());
        el.statNext.textContent = eta ? `${Math.ceil(eta/1000)}s` : 'due';
      };
      update();
      cooldownTimerId = setInterval(update, 250);
    }
    function stopTestCooldown() {
      if (cooldownTimerId !== null) {
        clearInterval(cooldownTimerId);
        cooldownTimerId = null;
      }
    }

    /**************************************************************************
     * PROBE CORE
     **************************************************************************/
    async function runProbe() {
      const url = settings.probeUrl;
      const timeoutMs = (settings.timeoutSec || 8) * 1000;
      const controller = new AbortController();
      const t0 = performance.now();

      const timeoutId = setTimeout(() => controller.abort('timeout'), timeoutMs);
      try {
        // NOTE: using no-cors so status is opaque; treat resolve as success
        await fetch(url, { mode: 'no-cors', signal: controller.signal, cache: 'no-store' });
        const ms = Math.round(performance.now() - t0);
        recordResult(true, ms);
        logln(`âœ… Success â€” ${ms} ms`);
        return { ok: true, ms };
      } catch (e) {
        const ms = Math.round(performance.now() - t0);
        recordResult(false, ms);
        logln(`âŒ Fail â€” ${e?.message || e} â€” ${ms} ms`);
        return { ok: false, ms, err: e };
      } finally {
        clearTimeout(timeoutId);
      }
    }

    function recordResult(ok, ms) {
      const ts = Date.now();
      lastProbeTs = ts; // IMPORTANT: update guard/cooldown baseline on every probe (auto or manual)
      localStorage.setItem(STORE_TS, String(lastProbeTs));

      history.push({ ts, ok, ms });
      trimHistory();

      // Update adaptive cadence
      // - On success: back off (slower) toward max
      // - On failure: tighten (faster) toward min
      if (ok) currentIntervalSec = clamp(Math.round(currentIntervalSec * 1.25), settings.minIntervalSec, settings.maxIntervalSec);
      else    currentIntervalSec = clamp(Math.round(currentIntervalSec * 0.5),  settings.minIntervalSec, settings.maxIntervalSec);

      // Refresh UI & cooldown to reflect new baseline
      refreshUI();
      startTestCooldown();

      // (Re)schedule next auto probe
      scheduleNextAuto();
    }

    /**************************************************************************
     * AUTO SCHEDULER
     **************************************************************************/
    function scheduleNextAuto() {
      if (autoTimer) clearTimeout(autoTimer);
      const delayMs = currentIntervalSec * 1000;
      autoTimer = setTimeout(async () => {
        el.btnTestNow.disabled = true;      // ensure manual button canâ€™t jump ahead of auto
        el.btnTestNow.textContent = 'Testingâ€¦';
        el.btnTestNow.setAttribute('aria-disabled', 'true');

        try {
          await runProbe();
        } finally {
          startTestCooldown(); // resumes countdown exactly from updated lastProbeTs
        }
      }, delayMs);
      el.statNext.textContent = `${currentIntervalSec}s`;
    }

    /**************************************************************************
     * UI HOOKS
     **************************************************************************/
    function refreshUI() {
      // chips
      el.chipUrl.textContent = settings.probeUrl;
      el.chipMin.textContent = settings.minIntervalSec;
      el.chipMax.textContent = settings.maxIntervalSec;
      el.chipTo.textContent = settings.timeoutSec;

      // stats
      const { rate, lat } = computeStats();
      el.statSuccessRate.textContent = (rate === null) ? 'â€”' : `${rate}%`;
      el.statLatency.textContent = (lat === null) ? 'â€”' : `${lat}`;
      el.statLast.textContent = fmtTime(lastProbeTs);

      // status badge
      const win = statusWindow();
      let status = 'Unknown', klass = '';
      if (win.length) {
        const okCount = win.filter(h => h.ok).length;
        const ratio = okCount / win.length;
        if (ratio >= 0.98) { status = 'Healthy'; klass = 'ok'; }
        else if (ratio >= 0.80) { status = 'Unstable'; klass = 'warn'; }
        else { status = 'Down'; klass = 'err'; }
      }
      el.badgeStatus.textContent = status;
      el.badgeStatus.className = `badge ${klass}`;
    }

    // Settings modal
    function openSettings() {
      el.inUrl.value = settings.probeUrl;
      el.inMin.value = settings.minIntervalSec;
      el.inMax.value = settings.maxIntervalSec;
      el.inTimeout.value = settings.timeoutSec;
      el.inHist.value = settings.historyHours;
      el.inStatus.value = settings.statusWindowMinutes;
      el.dlg.showModal();
    }
    function closeSettings() { el.dlg.close(); }
    function saveSettingsFromModal() {
      settings.probeUrl = (el.inUrl.value || DEFAULTS.probeUrl).trim();
      settings.minIntervalSec = Math.max(1, Number(el.inMin.value || DEFAULTS.minIntervalSec));
      settings.maxIntervalSec = Math.max(settings.minIntervalSec, Number(el.inMax.value || DEFAULTS.maxIntervalSec));
      settings.timeoutSec = Math.max(1, Number(el.inTimeout.value || DEFAULTS.timeoutSec));
      settings.historyHours = Math.max(1, Number(el.inHist.value || DEFAULTS.historyHours));
      settings.statusWindowMinutes = Math.max(1, Number(el.inStatus.value || DEFAULTS.statusWindowMinutes));
      saveSettings();

      // Reset adaptive cadence within new bounds
      currentIntervalSec = clamp(currentIntervalSec, settings.minIntervalSec, settings.maxIntervalSec);

      refreshUI();
      startTestCooldown(); // immediately recompute countdown
      scheduleNextAuto();

      closeSettings();
      logln('âš™ï¸ Settings saved.');
    }

    // Reset
    function resetData() {
      if (!confirm('Reset history and timers?')) return;
      history = [];
      saveHistory();
      lastProbeTs = 0;
      localStorage.removeItem(STORE_TS);
      currentIntervalSec = clamp(
        Math.round((settings.minIntervalSec + settings.maxIntervalSec) / 2),
        settings.minIntervalSec,
        settings.maxIntervalSec
      );
      refreshUI();
      startTestCooldown();
      scheduleNextAuto();
      logln('ðŸ—‘ï¸ Data reset.');
    }

    /**************************************************************************
     * EVENTS
     **************************************************************************/
    el.btnSettings.addEventListener('click', openSettings);
    el.btnCloseSettings.addEventListener('click', closeSettings);
    el.btnCancel.addEventListener('click', closeSettings);
    el.btnSave.addEventListener('click', saveSettingsFromModal);

    el.btnReset.addEventListener('click', resetData);

    el.btnTestNow.addEventListener('click', async () => {
      // Guard: only runnable when allowed
      if (msUntilAllowed() > 0) {
        startTestCooldown();
        return;
      }
      el.btnTestNow.disabled = true;
      el.btnTestNow.textContent = 'Testingâ€¦';
      el.btnTestNow.setAttribute('aria-disabled', 'true');

      try {
        // Record trigger time up-front to prevent rapid re-clicks
        lastProbeTs = Date.now();
        localStorage.setItem(STORE_TS, String(lastProbeTs));
        refreshUI();
        startTestCooldown();

        await runProbe();
      } catch (e) {
        console.error(e);
      } finally {
        startTestCooldown(); // ensures exact countdown from the probe time
      }
    });

    /**************************************************************************
     * BOOT
     **************************************************************************/
    function boot() {
      refreshUI();
      startTestCooldown();
      scheduleNextAuto();
      logln('ðŸš€ Ready.');
    }
    boot();
  </script>
</body>
</html>