<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>exist – Probe</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0b1220; --card: #131c2e; --text: #e8eefc; --muted: #a7b3cc;
      --ok: #21c16b; --warn: #ffb703; --bad: #ff5d5d; --accent: #5ac8ff;
      --grid: #1f2a44; --border: #1e2840;
      --tooltip-bg: #0e1728; --tooltip-border: #203055;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; padding: 20px; background: var(--bg); color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
    }
    .page { max-width: 1100px; margin: 0 auto; display: grid; gap: 16px; grid-template-columns: 1fr; }
    header { display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 12px; }
    .title { font-size: 1.2rem; color: var(--muted); display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
    .status-badge {
      display: inline-flex; align-items: center; gap: 8px; padding: 8px 12px;
      border-radius: 999px; font-weight: 600;
    }
    .status-dot { width: 10px; height: 10px; border-radius: 50%; box-shadow: 0 0 8px currentColor; }
    .badge-healthy { background: color-mix(in srgb, var(--ok) 15%, transparent); color: var(--ok); }
    .badge-unstable { background: color-mix(in srgb, var(--warn) 15%, transparent); color: var(--warn); }
    .badge-down { background: color-mix(in srgb, var(--bad) 15%, transparent); color: var(--bad); }

    .card { background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 16px; }
    .row { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; }
    .pill {
      background: #0e1728; border: 1px solid #203055; color: var(--muted);
      padding: 6px 10px; border-radius: 8px; font-size: 0.95rem;
    }
    button {
      background: #17335a; color: #e8eefc; border: 1px solid #2a4c7b;
      padding: 8px 12px; border-radius: 8px; cursor: pointer; font-weight: 600;
    }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    input[type="text"], input[type="number"] {
      background: #0e1728; color: var(--text); border: 1px solid #203055;
      padding: 8px 10px; border-radius: 8px;
    }
    input[type="text"] { min-width: 320px; }
    label { color: var(--muted); }

    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 12px; }
    .big { font-size: 1.6rem; font-weight: 700; color: var(--accent); }
    .hint { color: var(--muted); font-size: 0.9rem; }

    /* Canvas */
    .canvas-wrap { position: relative; }
    #historyCanvas { width: 100%; height: 340px; display: block; }

    /* Tooltip */
    .tooltip {
      position: fixed; z-index: 1000; pointer-events: none;
      background: var(--tooltip-bg); color: var(--text);
      border: 1px solid var(--tooltip-border); border-radius: 8px;
      padding: 6px 8px; font-size: 12px; box-shadow: 0 6px 16px rgba(0,0,0,0.35);
      white-space: nowrap; transform: translate(8px, 8px);
    }

    .divider { height: 1px; background: var(--border); margin: 6px 0 10px; }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <div class="title">
        <div>exist</div>
        <div class="hint">· Probing: <span id="probeUrlLabel">https://www.yahoo.com/favicon.ico</span></div>
      </div>
      <div id="statusBadge" class="status-badge badge-down">
        <span class="status-dot" id="statusDot"></span>
        <span id="statusText">Starting…</span>
      </div>
    </header>

    <!-- URL & Limits & Windows -->
    <section class="card">
      <div class="row" style="gap:8px 12px;">
        <label for="urlInput">Probe URL:</label>
        <input id="urlInput" type="text" placeholder="https://example.com/favicon.ico or example.com" />
        <button id="applyUrlBtn" title="Apply and start probing this URL">Apply</button>

        <label for="minIntervalInput">Min interval (s):</label>
        <input id="minIntervalInput" type="number" min="1" step="1" value="10" />
        <label for="maxIntervalInput">Max interval (s):</label>
        <input id="maxIntervalInput" type="number" min="1" step="1" value="30" />
        <button id="applyLimitsBtn" title="Apply new cadence limits">Apply limits</button>

        <label for="timeoutInput">Timeout (s):</label>
        <input id="timeoutInput" type="number" min="0.1" step="0.1" value="2" />
        <label for="historyHoursInput">History window (hours):</label>
        <input id="historyHoursInput" type="number" min="0.1" step="0.1" value="2" />
        <label for="statusMinutesInput">Status window (minutes):</label>
        <input id="statusMinutesInput" type="number" min="1" step="1" value="5" />
        <button id="applyWindowsBtn" title="Apply timeout & windows">Apply settings</button>

        <div class="pill">Current interval: <strong id="intervalText">–</strong></div>
        <div class="pill">Last test: <strong id="lastTestText">–</strong></div>
        <div class="pill"><span id="statusWindowLabel">5‑min</span> success: <strong id="fiveMinSuccess">–</strong></div>
        <button id="testNowBtn" title="Run a test immediately">Test now</button>
        <button id="clearBtn" title="Clear stored history (last window)">Clear history</button>
      </div>
      <div class="divider"></div>
      <div class="grid">
        <div>
          <div class="hint">Overall (<span id="overallWindowLabel">last 5 minutes</span>)</div>
          <div class="big" id="overallLabel">Calculating…</div>
          <div class="hint" id="adviceText"></div>
        </div>
        <div>
          <div class="hint">Notes</div>
          <ul class="hint" style="margin-top:6px;">
            <li>Adaptive cadence (configurable bounds): <strong id="notesMin">10s</strong> min, <strong id="notesMax">30s</strong> max.</li>
            <li>Timeout: <strong id="notesTimeout">2s</strong> (latency ≥ timeout counts as failure/slow; points colored red).</li>
            <li>History window: <strong id="notesHistory">2 hours</strong> (rolling). Status window: <strong id="notesStatus">5 minutes</strong>.</li>
            <li>Use public endpoints. <code>http://www.gstatic.com/generate_204</code> is supported.</li>
          </ul>
        </div>
      </div>
    </section>

    <section class="card">
      <div class="row">
        <div class="pill">Latency (ms) over <span id="historyWindowLabel">last 2 hours</span></div>
      </div>
      <div class="canvas-wrap">
        <canvas id="historyCanvas"></canvas>
      </div>
      <div class="hint" style="margin-top:6px;">
        Hover the chart to see a tooltip with timestamp and duration. Green = under timeout; Red = timeout or slower.
      </div>
    </section>
  </div>

  <!-- Tooltip element (hidden by default) -->
  <div id="tooltip" class="tooltip" style="display:none;"></div>

  <script>
    // ===================== Logging subsystem =====================
    const qp = new URLSearchParams(location.search);
    const LOG_LEVEL = (qp.get("log") || "info").toLowerCase(); // debug|info|warn|error
    const TRACE = qp.get("trace") === "1";
    const NET = qp.get("net") === "1";

    const LEVELS = { debug: 10, info: 20, warn: 30, error: 40 };
    const curLevel = LEVELS[LOG_LEVEL] ?? LEVELS.info;

    const fmtTime = () => new Date().toISOString();
    const styles = {
      base: "padding:1px 6px;border-radius:6px;color:#fff;font-weight:700",
      debug: "background:#6b7280",
      info:  "background:#2563eb",
      warn:  "background:#f59e0b",
      error: "background:#dc2626"
    };
    function logAt(level, tag, msg, ...rest) {
      if (LEVELS[level] < curLevel) return;
      const s = styles[level] || styles.info;
      const t = fmtTime();
      const fn = level === "error" ? console.error
              : level === "warn" ? console.warn
              : level === "debug" ? console.debug
              : console.log;
      try { fn(`%c${tag} ${t} — ${msg}`, `${styles.base};${s}`, ...rest); }
      catch { console.log(`[${tag}] ${t} — ${msg}`, ...rest); }
    }
    const LOG = {
      debug: (msg, ...rest) => logAt("debug", "DEBUG", msg, ...rest),
      info:  (msg, ...rest) => logAt("info",  "INFO",  msg, ...rest),
      warn:  (msg, ...rest) => logAt("warn",  "WARN",  msg, ...rest),
      error: (msg, ...rest) => logAt("error", "ERROR", msg, ...rest),
      group: (label) => { if (TRACE) console.group?.(label); },
      groupEnd: () => { if (TRACE) console.groupEnd?.(); },
      time: (label) => { if (NET) console.time?.(label); },
      timeEnd: (label) => { if (NET) console.timeEnd?.(label); },
    };
    LOG.info(`Booting exist (level=${LOG_LEVEL}, trace=${TRACE}, net=${NET})`);

    // ------------------ Config (defaults) ------------------
    const DEFAULT_PROBE_URL = "https://www.yahoo.com/favicon.ico";
    const DEFAULT_MIN_SEC = 10;
    const DEFAULT_MAX_SEC = 30;
    const DEFAULT_TIMEOUT_SEC = 2;
    const DEFAULT_HISTORY_HOURS = 2;
    const DEFAULT_STATUS_MINUTES = 5;

    const STORAGE_KEY = "internetMonitorHistoryV1";
    const SETTINGS_KEY = "internetMonitorSettingsV1";
    const STATUS_THRESHOLDS = { healthy: 0.90, unstable: 0.60 };

    // ------------------ State ------------------
    let timerId = null;
    let lastRunAt = 0;
    let history = loadHistory();

    // Settings (probe URL + limits + timeout + windows)
    let settings = loadSettings();
    let probeUrl = settings?.probeUrl || DEFAULT_PROBE_URL;
    let minIntervalMs = settings?.minIntervalMs ?? DEFAULT_MIN_SEC * 1000;
    let maxIntervalMs = settings?.maxIntervalMs ?? DEFAULT_MAX_SEC * 1000;
    let timeoutMs     = settings?.timeoutMs     ?? DEFAULT_TIMEOUT_SEC * 1000;
    let historyWindowMs = settings?.historyWindowMs ?? DEFAULT_HISTORY_HOURS * 3600 * 1000;
    let statusWindowMs  = settings?.statusWindowMs  ?? DEFAULT_STATUS_MINUTES * 60 * 1000;

    // Start interval at midpoint within bounds
    let currentInterval = clamp(Math.round((minIntervalMs + maxIntervalMs) / 2), minIntervalMs, maxIntervalMs);

    // ------------------ DOM ------------------
    const intervalText = document.getElementById("intervalText");
    const lastTestText = document.getElementById("lastTestText");
    const fiveMinSuccess = document.getElementById("fiveMinSuccess");
    const statusText = document.getElementById("statusText");
    const statusBadge = document.getElementById("statusBadge");
    const statusDot = document.getElementById("statusDot");
    const testNowBtn = document.getElementById("testNowBtn");
    const clearBtn = document.getElementById("clearBtn");
    const overallLabel = document.getElementById("overallLabel");
    const adviceText = document.getElementById("adviceText");
    const historyCanvas = document.getElementById("historyCanvas");
    const tooltipEl = document.getElementById("tooltip");
    const probeUrlLabel = document.getElementById("probeUrlLabel");
    const urlInput = document.getElementById("urlInput");
    const applyUrlBtn = document.getElementById("applyUrlBtn");
    const minIntervalInput = document.getElementById("minIntervalInput");
    const maxIntervalInput = document.getElementById("maxIntervalInput");
    const applyLimitsBtn = document.getElementById("applyLimitsBtn");
    const timeoutInput = document.getElementById("timeoutInput");
    const historyHoursInput = document.getElementById("historyHoursInput");
    const statusMinutesInput = document.getElementById("statusMinutesInput");
    const applyWindowsBtn = document.getElementById("applyWindowsBtn");
    const notesMin = document.getElementById("notesMin");
    const notesMax = document.getElementById("notesMax");
    const notesTimeout = document.getElementById("notesTimeout");
    const notesHistory = document.getElementById("notesHistory");
    const notesStatus = document.getElementById("notesStatus");
    const statusWindowLabel = document.getElementById("statusWindowLabel");
    const overallWindowLabel = document.getElementById("overallWindowLabel");
    const historyWindowLabel = document.getElementById("historyWindowLabel");
    const ctx = historyCanvas.getContext("2d");

    // Initialize labels & inputs
    probeUrlLabel.textContent = probeUrl;
    urlInput.value = probeUrl;
    minIntervalInput.value   = Math.round(minIntervalMs / 1000);
    maxIntervalInput.value   = Math.round(maxIntervalMs / 1000);
    timeoutInput.value       = +(timeoutMs / 1000).toFixed(1);
    historyHoursInput.value  = +(historyWindowMs / 3600000).toFixed(1);
    statusMinutesInput.value = Math.round(statusWindowMs / 60000);

    refreshNotesAndWindowLabels();

    // ------------------ Utilities ------------------
    function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
    function msToHuman(ms) { return Math.round(ms / 1000) + "s"; }
    function humanizeWindow(ms) {
      if (ms >= 3600000) {
        const h = (ms / 3600000);
        return (h % 1 === 0 ? h.toFixed(0) : h.toFixed(1)) + " hours";
      } else {
        return Math.round(ms / 60000) + " minutes";
      }
    }
    function humanizeShort(ms) {
      if (ms >= 3600000) return (ms/3600000).toFixed(1) + " h";
      if (ms >= 60000) return Math.round(ms/60000) + " min";
      return Math.round(ms/1000) + " s";
    }
    function formatTime(ts) {
      const d = new Date(ts);
      return d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" });
    }
    function saveHistory() {
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(history)); }
      catch (e) { LOG.error("Failed to save history to localStorage", e); }
    }
    function loadHistory() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) { LOG.info("No saved history found"); return []; }
        const parsed = JSON.parse(raw);
        const filtered = Array.isArray(parsed) ? parsed.filter(p => typeof p.t === "number" && typeof p.ok === "boolean") : [];
        LOG.info(`Loaded ${filtered.length} history points from storage`);
        return filtered;
      } catch (e) { LOG.error("Failed to load/parse history from localStorage", e); return []; }
    }
    function loadSettings() {
      try {
        const raw = localStorage.getItem(SETTINGS_KEY);
        if (!raw) return {};
        const parsed = JSON.parse(raw);
        return (parsed && typeof parsed === "object") ? parsed : {};
      } catch (e) {
        LOG.error("Failed to load settings", e);
        return {};
      }
    }
    function saveSettings() {
      try {
        localStorage.setItem(SETTINGS_KEY, JSON.stringify({
          probeUrl,
          minIntervalMs,
          maxIntervalMs,
          timeoutMs,
          historyWindowMs,
          statusWindowMs
        }));
      } catch (e) {
        LOG.error("Failed to save settings", e);
      }
    }
    function trimHistory(now = Date.now()) {
      const cutoff = now - historyWindowMs;
      const before = history.length;
      history = history.filter(p => p.t >= cutoff);
      const removed = before - history.length;
      if (removed > 0) LOG.debug(`Trimmed ${removed} points older than ${new Date(cutoff).toISOString()}`);
    }

    function refreshNotesAndWindowLabels() {
      notesMin.textContent = `${Math.round(minIntervalMs/1000)}s`;
      notesMax.textContent = `${Math.round(maxIntervalMs/1000)}s`;
      notesTimeout.textContent = `${+(timeoutMs/1000).toFixed(1)}s`;
      notesHistory.textContent = humanizeWindow(historyWindowMs);
      notesStatus.textContent = humanizeWindow(statusWindowMs);
      statusWindowLabel.textContent = humanizeShort(statusWindowMs);
      overallWindowLabel.textContent = `last ${humanizeWindow(statusWindowMs)}`;
      historyWindowLabel.textContent = `last ${humanizeWindow(historyWindowMs)}`;
    }

    // Normalize user input into a usable URL
    function normalizeProbeUrl(input) {
      if (!input) return null;
      let s = (input + "").trim();
      if (!s) return null;
      if (!/^https?:\/\//i.test(s)) s = "https://" + s; // default to https
      let urlObj;
      try { urlObj = new URL(s); }
      catch (e) { LOG.error("Invalid URL entered", s, e); return null; }
      if (!urlObj.pathname || urlObj.pathname === "/") urlObj.pathname = "/favicon.ico"; // default path
      urlObj.hash = "";
      return urlObj.toString();
    }

    function setProbeUrl(newUrlStr) {
      const normalized = normalizeProbeUrl(newUrlStr);
      if (!normalized) { LOG.warn("Probe URL not changed – invalid input"); return false; }
      probeUrl = normalized;
      probeUrlLabel.textContent = probeUrl;
      urlInput.value = probeUrl;
      saveSettings();
      LOG.info("Probe URL updated", { probeUrl });

      // Reset cadence to midpoint within current bounds
      currentInterval = clamp(Math.round((minIntervalMs + maxIntervalMs)/2), minIntervalMs, maxIntervalMs);
      clearTimeout(timerId);
      scheduleNext(0, "url-change");
      return true;
    }

    function applyLimits() {
      const minSec = Number(minIntervalInput.value);
      const maxSec = Number(maxIntervalInput.value);

      if (!Number.isFinite(minSec) || !Number.isFinite(maxSec) || minSec <= 0 || maxSec <= 0) {
        LOG.warn("Invalid limits: must be positive numbers (seconds)");
        alert("Invalid limits. Please enter positive numbers (seconds).");
        return false;
      }
      if (maxSec < minSec) {
        LOG.warn("Invalid limits: max must be ≥ min");
        alert("Invalid limits. Max interval must be greater than or equal to Min interval.");
        return false;
      }

      minIntervalMs = Math.round(minSec * 1000);
      maxIntervalMs = Math.round(maxSec * 1000);

      // Clamp current interval to new bounds
      const before = currentInterval;
      currentInterval = clamp(currentInterval, minIntervalMs, maxIntervalMs);
      LOG.info(`Limits applied: min=${minIntervalMs}ms, max=${maxIntervalMs}ms; interval clamped ${before}→${currentInterval}`);
      saveSettings();
      refreshNotesAndWindowLabels();

      clearTimeout(timerId);
      scheduleNext(0, "limits-change");
      return true;
    }

    function applyWindows() {
      const tSec = Number(timeoutInput.value);
      const hHours = Number(historyHoursInput.value);
      const sMin = Number(statusMinutesInput.value);

      if (!Number.isFinite(tSec) || tSec <= 0) {
        alert("Timeout must be a positive number (seconds).");
        return false;
      }
      if (!Number.isFinite(hHours) || hHours <= 0) {
        alert("History window must be a positive number (hours).");
        return false;
      }
      if (!Number.isFinite(sMin) || sMin <= 0) {
        alert("Status window must be a positive number (minutes).");
        return false;
      }

      timeoutMs = Math.round(tSec * 1000);
      historyWindowMs = Math.round(hHours * 3600000);
      statusWindowMs = Math.round(sMin * 60000);

      saveSettings();
      refreshNotesAndWindowLabels();

      // Trim & redraw with new window, reschedule
      clearTimeout(timerId);
      updateUI();
      scheduleNext(0, "windows-change");
      return true;
    }

    // ------------------ Probe (fetch + timeout, no-cors) ------------------
    async function probeOnce() {
      LOG.group("probeOnce()");
      const label = "probeOnce-duration";
      const start = performance.now();

      const controller = new AbortController();
      const to = setTimeout(() => controller.abort(), timeoutMs);

      const src = probeUrl + (probeUrl.includes("?") ? "&" : "?") + "_=" + Date.now();

      try {
        if (NET) LOG.time(label);
        LOG.debug("Starting fetch probe", { url: src, timeoutMs });

        await fetch(src, { mode: "no-cors", signal: controller.signal });

        const duration = performance.now() - start;
        clearTimeout(to);
        if (NET) LOG.timeEnd(label);
        LOG.info(`Probe success in ${Math.round(duration)} ms`);
        LOG.groupEnd();
        return { ok: true, duration };
      } catch (err) {
        const duration = performance.now() - start;
        clearTimeout(to);
        if (NET) LOG.timeEnd(label);
        const isAbort = err && (err.name === "AbortError" || err.code === 20);
        LOG.warn(`Probe ${isAbort ? "timeout" : "error"} after ${Math.round(duration)} ms`, err);
        LOG.groupEnd();
        return { ok: false, duration, error: isAbort ? "timeout" : "error" };
      }
    }

    // ------------------ Scheduling ------------------
    function scheduleNext(delay = currentInterval, reason = "normal") {
      clearTimeout(timerId);
      LOG.debug(`Scheduling next run in ${delay} ms (reason=${reason})`);
      timerId = setTimeout(runOnce, delay);
    }

    function adjustInterval(ok) {
      const before = currentInterval;
      if (!ok) {
        // Failure → increase frequency (shorter interval), bounded by minIntervalMs
        currentInterval = Math.max(minIntervalMs, Math.round(currentInterval * 0.70));
      } else {
        // Success → decrease frequency (longer interval), bounded by maxIntervalMs
        currentInterval = Math.min(maxIntervalMs, Math.round(currentInterval * 1.18 + 500));
      }
      LOG.info(`Cadence ${ok ? "backoff" : "tighten"}: ${before} → ${currentInterval} ms (bounds ${minIntervalMs}..${maxIntervalMs})`);
    }

    // ------------------ Status (windowed) ------------------
    function getWindowStats(now = Date.now()) {
      const cutoff = now - statusWindowMs;
      const windowData = history.filter(p => p.t >= cutoff);
      const n = windowData.length;
      const succ = windowData.reduce((a, p) => a + (p.ok ? 1 : 0), 0);
      const rate = n ? succ / n : 0;
      let label = "Down", badgeClass = "badge-down", tip = "Frequent failures detected. Check cabling/ISP/router/DNS.";
      if (rate >= STATUS_THRESHOLDS.healthy) { label = "Healthy"; badgeClass = "badge-healthy"; tip = "Connectivity looks solid."; }
      else if (rate >= STATUS_THRESHOLDS.unstable) { label = "Unstable"; badgeClass = "badge-unstable"; tip = "Intermittent issues observed. Monitor closely."; }
      LOG.debug(`Status window stats: n=${n}, succ=${succ}, rate=${(rate*100).toFixed(1)}%, label=${label}`);
      return { n, succ, rate, label, badgeClass, tip };
    }

    // ------------------ Canvas Chart: latency (ms), threshold-colored ------------------
    function drawHistoryChart() {
      const wCss = historyCanvas.clientWidth || 800;
      const hCss = historyCanvas.clientHeight || 340;
      const dpr = window.devicePixelRatio || 1;
      historyCanvas.width = Math.max(1, Math.floor(wCss * dpr));
      historyCanvas.height = Math.max(1, Math.floor(hCss * dpr));
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      const w = wCss, h = hCss;
      const padLeft = 56, padRight = 20, padTop = 20, padBottom = 36;
      const plotW = w - padLeft - padRight;
      const plotH = h - padTop - padBottom;

      ctx.clearRect(0, 0, w, h);

      const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--grid').trim() || '#1f2a44';
      const textColor = getComputedStyle(document.documentElement).getPropertyValue('--muted').trim() || '#a7b3cc';

      // Time window
      const now = Date.now();
      const startTs = now - historyWindowMs;

      // Determine y-range from data and timeout
      let maxLatency = timeoutMs;
      for (const p of history) {
        if (p.t < startTs) continue;
        if (p.t > now) break;
        maxLatency = Math.max(maxLatency, p.dt || 0);
      }
      // Pad top 15% for headroom
      const yMax = Math.max(100, Math.ceil(maxLatency * 1.15));
      const yMin = 0;

      // Grid: horizontal ms lines (4 ticks)
      ctx.strokeStyle = gridColor; ctx.lineWidth = 1;
      const yTicks = 4;
      ctx.fillStyle = textColor; ctx.font = '12px system-ui';
      for (let i = 0; i <= yTicks; i++) {
        const v = yMin + (i * (yMax - yMin) / yTicks);
        const y = padTop + (1 - (v - yMin) / (yMax - yMin)) * plotH;
        ctx.beginPath(); ctx.moveTo(padLeft, y); ctx.lineTo(padLeft + plotW, y); ctx.stroke();
        ctx.fillText(`${Math.round(v)} ms`, 4, y + 4);
      }

      // Timeout threshold line
      const yThresh = padTop + (1 - (timeoutMs - yMin) / (yMax - yMin)) * plotH;
      ctx.strokeStyle = 'rgba(255, 183, 3, 0.75)'; // amber
      ctx.setLineDash([6, 4]);
      ctx.beginPath(); ctx.moveTo(padLeft, yThresh); ctx.lineTo(padLeft + plotW, yThresh); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = textColor; ctx.fillText(`timeout (${Math.round(timeoutMs)} ms)`, padLeft + 6, yThresh - 6);

      // X grid: choose a reasonable step based on window size
      const mins = historyWindowMs / 60000;
      let stepMin = 10;
      if (mins <= 15) stepMin = 2;
      else if (mins <= 30) stepMin = 5;
      else if (mins <= 60) stepMin = 10;
      else if (mins <= 120) stepMin = 10;
      else stepMin = 30;

      for (let m = 0; m <= Math.ceil(mins); m += stepMin) {
        const ts = startTs + m * 60000;
        const x = padLeft + ((ts - startTs) / historyWindowMs) * plotW;
        ctx.strokeStyle = gridColor;
        ctx.beginPath(); ctx.moveTo(x, padTop); ctx.lineTo(x, padTop + plotH); ctx.stroke();
        ctx.fillStyle = textColor;
        const timeStr = new Date(ts).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        ctx.fillText(timeStr, x - 18, padTop + plotH + 18);
      }

      const xForTs = (ts) => padLeft + ((ts - startTs) / historyWindowMs) * plotW;
      const yForMs = (ms) => padTop + (1 - (ms - yMin) / (yMax - yMin)) * plotH;

      // Draw line segments colored by threshold, and markers per point
      ctx.lineWidth = 2;
      let prevX = null, prevY = null, prevGood = null;
      for (let i = 0; i < history.length; i++) {
        const p = history[i];
        if (p.t < startTs) continue;
        const x = xForTs(p.t);
        if (x < padLeft) continue;
        if (x > padLeft + plotW) break;

        const ms = Math.max(0, p.dt || 0);
        const y = yForMs(ms);
        const good = p.ok && ms < timeoutMs;

        // Segment from prev to current, colored by current point's state
        if (prevX !== null && prevY !== null) {
          ctx.strokeStyle = good ? '#21c16b' : '#ff5d5d';
          ctx.beginPath();
          ctx.moveTo(prevX, prevY);
          ctx.lineTo(x, y);
          ctx.stroke();
        }

        // Marker
        ctx.fillStyle = good ? '#21c16b' : '#ff5d5d';
        ctx.beginPath(); ctx.arc(x, y, 2.8, 0, Math.PI * 2); ctx.fill();

        prevX = x; prevY = y; prevGood = good;
      }

      // Hover tooltip (nearest point)
      historyCanvas.onmousemove = (ev) => {
        const rect = historyCanvas.getBoundingClientRect();
        const xCss = ev.clientX - rect.left;
        const yCss = ev.clientY - rect.top;

        const xPlot = xCss - padLeft;
        const yPlot = yCss - padTop;
        if (xPlot < 0 || xPlot > plotW || yPlot < 0 || yPlot > plotH) {
          tooltipEl.style.display = 'none'; return;
        }

        const ts = startTs + (xPlot / plotW) * historyWindowMs;

        let nearest = null, best = Infinity, nX = null, nY = null;
        for (const p of history) {
          const diff = Math.abs(p.t - ts);
          if (diff < best) { best = diff; nearest = p; nX = xForTs(p.t); nY = yForMs(Math.max(0, p.dt || 0)); }
        }
        if (!nearest) { tooltipEl.style.display = 'none'; return; }

        const ms = Math.max(0, nearest.dt || 0);
        const good = nearest.ok && ms < timeoutMs;
        tooltipEl.textContent = `${formatTime(nearest.t)} — ${good ? "Success" : "Failure"} (${Math.round(ms)} ms)`;
        tooltipEl.style.display = 'block';
        tooltipEl.style.left = `${ev.clientX + 8}px`;
        tooltipEl.style.top = `${ev.clientY + 8}px`;

        // Crosshair
        drawHistoryChart(); // clear overlays by redrawing
        ctx.save();
        ctx.strokeStyle = 'rgba(90,200,255,0.35)';
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(nX, padTop); ctx.lineTo(nX, padTop + plotH);
        ctx.moveTo(padLeft, nY); ctx.lineTo(padLeft + plotW, nY);
        ctx.stroke();
        ctx.restore();
      };
      historyCanvas.onmouseleave = () => { tooltipEl.style.display = 'none'; drawHistoryChart(); };
    }

    // ------------------ UI ------------------
    function updateUI(lastPoint = null) {
      LOG.group("updateUI()");
      const now = Date.now();
      trimHistory(now);
      saveHistory();

      intervalText.textContent = msToHuman(currentInterval);
      lastTestText.textContent = lastPoint ? formatTime(lastPoint.t) : (history.length ? formatTime(history.at(-1).t) : "–");

      const { rate, label, badgeClass, tip, n } = getWindowStats(now);
      fiveMinSuccess.textContent = n ? Math.round(rate * 100) + "%" : "No data";

      const prevLabel = overallLabel.textContent;
      overallLabel.textContent = label;
      adviceText.textContent = tip;

      statusBadge.classList.remove("badge-healthy", "badge-unstable", "badge-down");
      statusBadge.classList.add(badgeClass);

      const last = lastPoint || history.at(-1);
      if (last) {
        const good = last.ok && (last.dt || 0) < timeoutMs;
        statusText.textContent = good ? "Internet is working" : "Internet is bad";
        statusDot.style.color = good ? "var(--ok)" : "var(--bad)";
      } else {
        statusText.textContent = "Waiting for first result…";
        statusDot.style.color = "var(--warn)";
      }

      if (prevLabel && prevLabel !== label) LOG.info(`Overall label changed: ${prevLabel} → ${label}`);

      drawHistoryChart();
      LOG.groupEnd();
    }

    // ------------------ Run Loop ------------------
    async function runOnce() {
      LOG.group("runOnce()");
      const now = Date.now();

      // Guardrail: never faster than minIntervalMs
      const since = now - lastRunAt;
      if (lastRunAt && since < minIntervalMs) {
        const wait = minIntervalMs - since;
        LOG.warn(`Throttled: last run ${since} ms ago, waiting ${wait} ms`);
        scheduleNext(wait, "throttled");
        LOG.groupEnd();
        return;
      }
      lastRunAt = now;

      const res = await probeOnce();
      const point = { t: Date.now(), ok: !!res.ok, dt: Math.round(res.duration) };
      history.push(point);
      LOG.info(`Result: ${point.ok ? "SUCCESS" : "FAIL"} (${point.dt} ms) @ ${new Date(point.t).toISOString()}`);

      updateUI(point);
      adjustInterval(point.ok);
      scheduleNext(currentInterval, "post-run");
      LOG.groupEnd();
    }

    // ------------------ Events ------------------
    function wireEvents() {
      testNowBtn.addEventListener("click", () => {
        LOG.info("Manual 'Test now' clicked");
        if (Date.now() - lastRunAt < minIntervalMs) {
          LOG.warn("Manual test throttled due to min-interval guard");
          testNowBtn.disabled = true;
          setTimeout(() => { testNowBtn.disabled = false; }, 1000);
          return;
        }
        clearTimeout(timerId);
        runOnce();
      });

      clearBtn.addEventListener("click", () => {
        LOG.warn("Clear history requested");
        if (!confirm("Clear monitoring history stored locally (within your history window)?")) {
          LOG.info("Clear history cancelled by user");
          return;
        }
        history = [];
        saveHistory();
        updateUI();
        LOG.info("History cleared");
      });

      applyUrlBtn.addEventListener("click", () => {
        const val = urlInput.value;
        if (setProbeUrl(val)) {
          LOG.info("Cadence reset (midpoint) after URL change", { currentInterval });
        }
      });
      urlInput.addEventListener("keydown", (e) => { if (e.key === "Enter") applyUrlBtn.click(); });

      applyLimitsBtn.addEventListener("click", () => { applyLimits(); });
      minIntervalInput.addEventListener("keydown", (e) => { if (e.key === "Enter") applyLimitsBtn.click(); });
      maxIntervalInput.addEventListener("keydown", (e) => { if (e.key === "Enter") applyLimitsBtn.click(); });

      applyWindowsBtn.addEventListener("click", () => { applyWindows(); });
      timeoutInput.addEventListener("keydown", (e) => { if (e.key === "Enter") applyWindowsBtn.click(); });
      historyHoursInput.addEventListener("keydown", (e) => { if (e.key === "Enter") applyWindowsBtn.click(); });
      statusMinutesInput.addEventListener("keydown", (e) => { if (e.key === "Enter") applyWindowsBtn.click(); });

      window.addEventListener("resize", () => {
        LOG.debug("Window resized — redrawing chart");
        drawHistoryChart();
      });
    }

    // ------------------ Start ------------------
    window.addEventListener("load", () => {
      LOG.group("boot()");
      wireEvents();
      updateUI();
      scheduleNext(0, "boot");
      LOG.groupEnd();
    });
  </script>
</body>
</html>